<!DOCTYPE html>

<html class="writer-html5" lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="../../../img/favicon.ico" rel="shortcut icon"/>
<title>Equivalent Resistance Using Graph Theory - Physics and Mathematics</title>
<link href="../../../css/theme.css" rel="stylesheet"/>
<link href="../../../css/theme_extra.css" rel="stylesheet"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" rel="stylesheet"/>
<script>
        // Current page data
        var mkdocs_page_name = "Equivalent Resistance Using Graph Theory";
        var mkdocs_page_input_path = "1 Physics/5 Circuits/Problem_1.md";
        var mkdocs_page_url = null;
      </script>
<!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/yaml.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/rust.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/python.min.js"></script>
<script>hljs.highlightAll();</script>
</head>
<body class="wy-body-for-nav" role="document">
<div class="wy-grid-for-nav">
<nav class="wy-nav-side stickynav" data-toggle="wy-nav-shift">
<div class="wy-side-scroll">
<div class="wy-side-nav-search">
<a class="icon icon-home" href="../../.."> Physics and Mathematics
        </a><div role="search">
<form action="../../../search.html" class="wy-form" id="rtd-search-form" method="get">
<input aria-label="Search docs" name="q" placeholder="Search docs" title="Type search term here" type="text"/>
</form>
</div>
</div>
<div aria-label="Navigation menu" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../..">Introduction</a>
</li>
</ul>
<p class="caption"><span class="caption-text">1 Physics</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal">1 Mechanics</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../1%20Mechanics/Problem_1/">Investigating the Range of a Projectile as a Function of the Angle of Projection</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../1%20Mechanics/Problem_2/">Investigating the Dynamics of a Forced Damped Pendulum</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">2 Gravity</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_1/">Orbital Period and Orbital Radius</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_2/">Escape Velocities and Cosmic Velocities</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_3/">Trajectories of a Freely Released Payload Near Earth</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">3 Waves</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../3%20Waves/Problem_1/">Interference Patterns on a Water Surface</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">4 Electromagnetism</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../4%20Electromagnetism/Problem_1/">Simulating the Effects of the Lorentz Force</a>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal current">5 Circuits</a>
<ul class="current">
<li class="toctree-l2 current"><a class="reference internal current" href="#">Equivalent Resistance Using Graph Theory</a>
<ul class="current">
<li class="toctree-l3"><a class="reference internal" href="#motivation">Motivation</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#theoretical-background">Theoretical Background</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#graph-theory-approach-to-circuit-analysis">Graph Theory Approach to Circuit Analysis</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#graph-representation-of-circuits">Graph Representation of Circuits</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#reduction-rules">Reduction Rules</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#algorithm-description">Algorithm Description</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#pseudocode">Pseudocode</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#implementation">Implementation</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#computational-model-and-visualization">Computational Model and Visualization</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#example-circuits">Example Circuits</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#analysis-and-efficiency">Analysis and Efficiency</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#algorithm-efficiency">Algorithm Efficiency</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#limitations-and-potential-improvements">Limitations and Potential Improvements</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#conclusion">Conclusion</a>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">6 Statistics</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../6%20Statistics/Problem_1/">Exploring the Central Limit Theorem through simulations</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../6%20Statistics/Problem_2/">Estimating Pi using Monte Carlo Methods</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">7 Measurements</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../7%20Measurements/Problem_1/">Measuring Earth's Gravitational Acceleration with a Pendulum</a>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">2 Mathematics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/1%20Linear_algebra/">Linear Algebra</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/2%20Analytic_geometry/">Analytic geometry</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/3%20Calculus/">Calculus</a>
</li>
</ul>
</div>
</div>
</nav>
<section class="wy-nav-content-wrap" data-toggle="wy-nav-shift">
<nav aria-label="Mobile navigation menu" class="wy-nav-top" role="navigation">
<i class="fa fa-bars" data-toggle="wy-nav-top"></i>
<a href="../../..">Physics and Mathematics</a>
</nav>
<div class="wy-nav-content">
<div class="rst-content"><div aria-label="breadcrumbs navigation" role="navigation">
<ul class="wy-breadcrumbs">
<li><a aria-label="Docs" class="icon icon-home" href="../../.."></a></li>
<li class="breadcrumb-item">1 Physics</li>
<li class="breadcrumb-item">5 Circuits</li>
<li class="breadcrumb-item active">Equivalent Resistance Using Graph Theory</li>
<li class="wy-breadcrumbs-aside">
</li>
</ul>
<hr/>
</div>
<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div class="section" itemprop="articleBody">
<h1 id="equivalent-resistance-using-graph-theory">Equivalent Resistance Using Graph Theory</h1>
<h2 id="motivation">Motivation</h2>
<p>Calculating equivalent resistance is a fundamental problem in electrical circuits, essential for understanding and designing efficient systems. While traditional methods involve iteratively applying series and parallel resistor rules, these approaches can become cumbersome for complex circuits with many components. Graph theory offers a powerful alternative, providing a structured and algorithmic way to analyze circuits.</p>
<p>By representing a circuit as a graph—where nodes correspond to junctions and edges represent resistors with weights equal to their resistance values—we can systematically simplify even the most intricate networks. This method not only streamlines calculations but also opens the door to automated analysis, making it particularly useful in modern applications like circuit simulation software, optimization problems, and network design.</p>
<p>Studying equivalent resistance through graph theory is valuable not only for its practical applications but also for the deeper insights it provides into the interplay between electrical and mathematical concepts. This approach highlights the versatility of graph theory, demonstrating its relevance across physics, engineering, and computer science.</p>
<h2 id="theoretical-background">Theoretical Background</h2>
<h3 id="graph-theory-approach-to-circuit-analysis">Graph Theory Approach to Circuit Analysis</h3>
<p>Electrical circuits can be represented as graphs, where:</p>
<ul>
<li>Nodes represent junctions or connection points</li>
<li>Edges represent circuit elements (resistors, batteries, etc.)</li>
</ul>
<p><img alt="Circuit to Graph Transformation" src="../images/graph_representation.png"/></p>
<p>This graph representation allows us to apply graph theory algorithms to analyze the circuit and calculate the equivalent resistance between any two nodes.</p>
<h3 id="graph-representation-of-circuits">Graph Representation of Circuits</h3>
<p>In the graph theory approach to circuit analysis:</p>
<ul>
<li><strong>Nodes</strong> (vertices) represent junctions or connection points in the circuit</li>
<li><strong>Edges</strong> represent resistors, with edge weights corresponding to resistance values</li>
<li>The <strong>source</strong> and <strong>target</strong> nodes represent the terminals across which we want to calculate the equivalent resistance</li>
</ul>
<h3 id="reduction-rules">Reduction Rules</h3>
<p>The algorithm for calculating equivalent resistance relies on two fundamental circuit reduction rules:</p>
<ol>
<li>
<p><strong>Series Reduction</strong>: When two resistors <span class="arithmatex">\(R_1\)</span> and <span class="arithmatex">\(R_2\)</span> are connected in series, they can be replaced by a single equivalent resistor <span class="arithmatex">\(R_{eq} = R_1 + R_2\)</span>.</p>
</li>
<li>
<p><strong>Parallel Reduction</strong>: When two resistors <span class="arithmatex">\(R_1\)</span> and <span class="arithmatex">\(R_2\)</span> are connected in parallel, they can be replaced by a single equivalent resistor <span class="arithmatex">\(R_{eq} = \frac{R_1 \cdot R_2}{R_1 + R_2}\)</span> or equivalently <span class="arithmatex">\(\frac{1}{R_{eq}} = \frac{1}{R_1} + \frac{1}{R_2}\)</span>.</p>
</li>
</ol>
<p>In graph terms:</p>
<ul>
<li>
<p><strong>Series Reduction</strong>: A node with exactly two connections can be eliminated, and its adjacent edges combined into a single edge with resistance equal to the sum of the original resistances.</p>
</li>
<li>
<p><strong>Parallel Reduction</strong>: Multiple edges between the same pair of nodes can be combined into a single edge with resistance calculated using the parallel resistor formula.</p>
</li>
</ul>
<h4 id="series-reduction">Series Reduction</h4>
<p>When resistors are connected in series (one after another with no branches), they can be replaced by a single equivalent resistor whose resistance is the sum of the individual resistances.</p>
<p><img alt="Series Reduction" src="../images/series_reduction.png"/></p>
<p><strong>Series Reduction Formula:</strong></p>
<p><span class="arithmatex">\(R_{eq} = R_1 + R_2 + ... + R_n\)</span></p>
<p><strong>Example Calculation:</strong></p>
<p><span class="arithmatex">\(R_{eq} = R_1 + R_2 = 10k\Omega + 20k\Omega = 30k\Omega\)</span></p>
<h4 id="parallel-reduction">Parallel Reduction</h4>
<p>When resistors are connected in parallel (providing multiple paths between the same two nodes), they can be replaced by a single equivalent resistor whose conductance (1/R) is the sum of the individual conductances.</p>
<p><img alt="Parallel Reduction" src="../images/parallel_reduction.png"/></p>
<p><strong>Parallel Reduction Formulas:</strong></p>
<p><span class="arithmatex">\(\frac{1}{R_{eq}} = \frac{1}{R_1} + \frac{1}{R_2} + ... + \frac{1}{R_n}\)</span></p>
<p>Alternatively:</p>
<p><span class="arithmatex">\(R_{eq} = \frac{R_1 \cdot R_2}{R_1 + R_2}\)</span> (for two resistors)</p>
<p><strong>Example Calculation:</strong></p>
<p><span class="arithmatex">\(\frac{1}{R_{eq}} = \frac{1}{30k\Omega} + \frac{1}{60k\Omega} = \frac{2}{60k\Omega} + \frac{1}{60k\Omega} = \frac{3}{60k\Omega} = \frac{1}{20k\Omega}\)</span></p>
<p>Therefore, <span class="arithmatex">\(R_{eq} = 20k\Omega\)</span></p>
<p>Or using the product/sum formula:</p>
<p><span class="arithmatex">\(R_{eq} = \frac{30k\Omega \cdot 60k\Omega}{30k\Omega + 60k\Omega} = \frac{1800k\Omega^2}{90k\Omega} = 20k\Omega\)</span></p>
<h4 id="delta-wye-y-transformation">Delta-Wye (Δ-Y) Transformation</h4>
<p>For more complex circuits that cannot be simplified using only series and parallel reductions, the Delta-Wye transformation can be used to convert between these two equivalent configurations.</p>
<p><img alt="Delta-Wye Transformation" src="../images/delta_wye_transformation.png"/></p>
<p><strong>Delta to Wye Transformation Formulas:</strong></p>
<p><span class="arithmatex">\(R_a = \frac{R_{ab} \cdot R_{ca}}{R_{ab} + R_{bc} + R_{ca}}\)</span></p>
<p><span class="arithmatex">\(R_b = \frac{R_{ab} \cdot R_{bc}}{R_{ab} + R_{bc} + R_{ca}}\)</span></p>
<p><span class="arithmatex">\(R_c = \frac{R_{bc} \cdot R_{ca}}{R_{ab} + R_{bc} + R_{ca}}\)</span></p>
<p><strong>Example Calculation:</strong></p>
<p><span class="arithmatex">\(R_a = \frac{10\Omega \cdot 30\Omega}{10\Omega + 20\Omega + 30\Omega} = \frac{300\Omega}{60\Omega} = 5\Omega\)</span></p>
<p><span class="arithmatex">\(R_b = \frac{10\Omega \cdot 20\Omega}{10\Omega + 20\Omega + 30\Omega} = \frac{200\Omega}{60\Omega} = 3.33\Omega\)</span></p>
<p><span class="arithmatex">\(R_c = \frac{20\Omega \cdot 30\Omega}{10\Omega + 20\Omega + 30\Omega} = \frac{600\Omega}{60\Omega} = 10\Omega\)</span></p>
<h3 id="algorithm-description">Algorithm Description</h3>
<h3 id="pseudocode">Pseudocode</h3>
<pre><code>Function CalculateEquivalentResistance(Graph G, Node source, Node target):
    // Make a copy of the graph to avoid modifying the original
    H = Copy(G)

    // Continue reducing the graph until only source and target nodes remain
    While number of nodes in H &gt; 2:
        // Try to reduce series connections
        series_nodes = IdentifySeriesNodes(H)
        series_nodes = FilterOut(series_nodes, [source, target])

        If series_nodes is not empty:
            node = First element of series_nodes
            H = ReduceSeries(H, node)
            Continue to next iteration

        // Try to reduce parallel connections
        parallel_pairs = IdentifyParallelEdges(H)

        If parallel_pairs is not empty:
            pair = First element of parallel_pairs
            H = ReduceParallel(H, pair)
            Continue to next iteration

        // If no series or parallel reductions are possible, try delta-wye transformation
        // or other advanced techniques

        // If no reductions are possible, break the loop
        Break

    // Check if the reduction was successful
    If H has exactly 2 nodes (source and target) and has an edge between them:
        Return the resistance of the edge between source and target
    Else:
        Raise an error or use advanced techniques

Function IdentifySeriesNodes(Graph G):
    Return all nodes in G that have exactly 2 connections

Function ReduceSeries(Graph G, Node node):
    // Get the two neighbors of the node
    n1, n2 = Neighbors of node in G

    // Get the resistances of the two edges
    r1 = Resistance of edge between n1 and node
    r2 = Resistance of edge between node and n2

    // Calculate the equivalent resistance
    r_eq = r1 + r2

    // Remove the node and its edges
    Remove node and its edges from G

    // Add a new edge between the neighbors with the equivalent resistance
    Add edge between n1 and n2 with resistance r_eq

    Return G

Function IdentifyParallelEdges(Graph G):
    Return all pairs of nodes that have multiple edges between them

Function ReduceParallel(Graph G, NodePair pair):
    u, v = pair

    // Get all resistances between the nodes
    resistances = All resistances of edges between u and v

    // Calculate the equivalent resistance
    r_eq = 1.0 / sum(1.0 / r for r in resistances)

    // Remove all edges between the nodes
    Remove all edges between u and v from G

    // Add a new edge with the equivalent resistance
    Add edge between u and v with resistance r_eq

    Return G
</code></pre>
<h2 id="implementation">Implementation</h2>
<p>The algorithm has been implemented in Python using the NetworkX library for graph manipulation. The implementation includes functions for:</p>
<ol>
<li>Creating and visualizing circuit graphs</li>
<li>Identifying series and parallel connections</li>
<li>Performing series and parallel reductions</li>
<li>Calculating the equivalent resistance between two nodes</li>
</ol>
<h2 id="computational-model-and-visualization">Computational Model and Visualization</h2>
<details>
<summary>Click to expand Python code</summary>
<pre><code class="language-python">import networkx as nx
import numpy as np
import matplotlib.pyplot as plt
import os

# Create directory for images if it doesn't exist
image_dir = os.path.join('docs', '1 Physics', '5 Circuits', 'images')
os.makedirs(image_dir, exist_ok=True)

def draw_circuit_graph(G, pos=None, title="Circuit Graph", save_path=None):
    """
    Draw a circuit graph with resistor values as edge labels.

    Args:
        G: NetworkX graph representing the circuit
        pos: Dictionary of node positions
        title: Title of the plot
        save_path: Path to save the plot
    """
    plt.figure(figsize=(10, 8))

    if pos is None:
        pos = nx.spring_layout(G, seed=42)  # For consistent layout

    # Draw the graph
    nx.draw(G, pos, with_labels=True, node_color='skyblue', node_size=500, font_size=12, font_weight='bold')

    # Draw edge labels (resistor values)
    edge_labels = {(u, v): f"{d['resistance']:.2f} Ω" for u, v, d in G.edges(data=True)}
    nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=10)

    plt.title(title, fontsize=14)
    plt.axis('off')

    # Save the plot if a save path is provided
    if save_path:
        plt.savefig(save_path, dpi=300, bbox_inches='tight')

    plt.close()

def identify_series_nodes(G):
    """
    Identify nodes that are in series in the graph.
    A node is in series if it has exactly two connections.

    Args:
        G: NetworkX graph representing the circuit

    Returns:
        List of nodes that are in series (excluding terminals)
    """
    series_nodes = [node for node in G.nodes() if G.degree(node) == 2]
    return series_nodes

def reduce_series(G, node):
    """
    Reduce a series connection at the specified node.

    Args:
        G: NetworkX graph representing the circuit
        node: Node to be eliminated (must have exactly two connections)

    Returns:
        Modified graph with the series connection reduced
    """
    # Get the two neighbors of the node
    neighbors = list(G.neighbors(node))
    if len(neighbors) != 2:
        raise ValueError(f"Node {node} does not have exactly two connections")

    n1, n2 = neighbors

    # Get the resistances of the two edges
    r1 = G[n1][node]['resistance']
    r2 = G[node][n2]['resistance']

    # Calculate the equivalent resistance
    r_eq = r1 + r2

    # Remove the node and its edges
    G.remove_node(node)

    # Add a new edge between the neighbors with the equivalent resistance
    G.add_edge(n1, n2, resistance=r_eq)

    return G

def identify_parallel_edges(G):
    """
    Identify pairs of nodes that have multiple edges between them (parallel resistors).

    Args:
        G: NetworkX graph representing the circuit

    Returns:
        List of node pairs that have parallel connections
    """
    # Convert to MultiGraph to find parallel edges
    MG = nx.MultiGraph(G)

    parallel_pairs = []
    for u, v, data in MG.edges(data=True):
        if MG.number_of_edges(u, v) &gt; 1:
            if (u, v) not in parallel_pairs and (v, u) not in parallel_pairs:
                parallel_pairs.append((u, v))

    return parallel_pairs

def reduce_parallel(G, node_pair):
    """
    Reduce parallel connections between a pair of nodes.

    Args:
        G: NetworkX graph representing the circuit
        node_pair: Tuple of nodes that have parallel connections

    Returns:
        Modified graph with the parallel connections reduced
    """
    u, v = node_pair

    # Get all edges between the nodes
    edges = []
    for n1, n2, data in G.edges(data=True):
        if (n1 == u and n2 == v) or (n1 == v and n2 == u):
            edges.append(data['resistance'])

    # Calculate the equivalent resistance (1/R_eq = 1/R1 + 1/R2 + ...)
    r_eq = 1.0 / sum(1.0 / r for r in edges)

    # Remove all edges between the nodes
    while G.has_edge(u, v):
        G.remove_edge(u, v)

    # Add a new edge with the equivalent resistance
    G.add_edge(u, v, resistance=r_eq)

    return G

def calculate_equivalent_resistance(G, source, target):
    """
    Calculate the equivalent resistance between two nodes in a circuit.

    Args:
        G: NetworkX graph representing the circuit
        source: Source node
        target: Target node

    Returns:
        Equivalent resistance between source and target
    """
    # Make a copy of the graph to avoid modifying the original
    H = G.copy()

    # Keep track of the reduction steps for visualization
    reduction_steps = []
    reduction_steps.append((H.copy(), "Initial Circuit"))

    # Continue reducing the graph until only the source and target nodes remain
    while len(H.nodes()) &gt; 2:
        # Try to reduce series connections
        series_nodes = identify_series_nodes(H)

        # Filter out source and target nodes
        series_nodes = [node for node in series_nodes if node != source and node != target]

        if series_nodes:
            # Reduce a series connection
            node = series_nodes[0]
            H = reduce_series(H, node)
            reduction_steps.append((H.copy(), f"After Series Reduction at Node {node}"))
            continue

        # Try to reduce parallel connections
        parallel_pairs = identify_parallel_edges(H)
        if parallel_pairs:
            # Reduce a parallel connection
            pair = parallel_pairs[0]
            H = reduce_parallel(H, pair)
            reduction_steps.append((H.copy(), f"After Parallel Reduction between Nodes {pair}"))
            continue

        # If no series or parallel reductions are possible, break the loop
        break

    # Check if the reduction was successful
    if len(H.nodes()) == 2 and H.has_edge(source, target):
        equivalent_resistance = H[source][target]['resistance']
    else:
        # For more complex circuits, we might need to use other methods
        raise ValueError("Could not reduce the circuit completely. Try using delta-wye transformations or other methods.")

    return equivalent_resistance, reduction_steps
</code></pre>
</details>
<p>The computational model represents electrical circuits as graphs and implements algorithms to systematically reduce these graphs to calculate equivalent resistance. The implementation visualizes each step of the reduction process, providing insights into how the algorithm works and how circuit simplification progresses.</p>
<h3 id="example-circuits">Example Circuits</h3>
<p>The implementation was tested on several example circuits:</p>
<h4 id="example-1-simple-series-circuit">Example 1: Simple Series Circuit</h4>
<p>A simple series circuit with three resistors (10kΩ, 20kΩ, and 30kΩ) connected in series.</p>
<p><img alt="Simple Series Circuit" src="../images/example_1_circuit.png"/></p>
<p>This graph represents a simple series circuit where three resistors are connected end-to-end, forming a single path for current flow. The algorithm identifies nodes with exactly two connections and sequentially reduces them.</p>
<p><strong>Calculation:</strong>
<span class="arithmatex">\(R_{eq} = R_1 + R_2 + R_3 = 10k\Omega + 20k\Omega + 30k\Omega = 60k\Omega\)</span></p>
<p>In series circuits, the equivalent resistance is the sum of all individual resistances because the same current flows through each resistor, following Kirchhoff's current law.</p>
<h4 id="example-2-simple-parallel-circuit">Example 2: Simple Parallel Circuit</h4>
<p>A simple parallel circuit with two resistors (10kΩ and 20kΩ) connected in parallel.</p>
<p><img alt="Simple Parallel Circuit" src="../images/example_2_circuit.png"/></p>
<p>This graph shows a parallel circuit where two resistors connect the same pair of nodes, providing multiple paths for current flow. The algorithm identifies parallel edges between nodes and combines them using the parallel resistance formula.</p>
<p><strong>Calculation:</strong>
<span class="arithmatex">\(\frac{1}{R_{eq}} = \frac{1}{R_1} + \frac{1}{R_2} = \frac{1}{10k\Omega} + \frac{1}{20k\Omega} = \frac{2}{20k\Omega} + \frac{1}{20k\Omega} = \frac{3}{20k\Omega}\)</span></p>
<p><span class="arithmatex">\(R_{eq} = \frac{20k\Omega}{3} \approx 6.67k\Omega\)</span></p>
<p>In parallel circuits, the equivalent conductance (1/R) is the sum of individual conductances, as voltage is the same across all resistors according to Kirchhoff's voltage law.</p>
<h4 id="example-3-mixed-series-parallel-circuit">Example 3: Mixed Series-Parallel Circuit</h4>
<p>A more complex circuit with a combination of series and parallel connections.</p>
<p><img alt="Mixed Series-Parallel Circuit" src="../images/example_3_circuit.png"/></p>
<p>This graph represents a mixed circuit containing both series and parallel elements. The algorithm systematically reduces this circuit by alternating between series and parallel reductions until only two nodes remain.</p>
<p>For mixed circuits, the reduction follows a specific order:</p>
<ol>
<li>Identify and reduce series connections: <span class="arithmatex">\(R_{series} = R_1 + R_2\)</span></li>
<li>Identify and reduce parallel connections: <span class="arithmatex">\(\frac{1}{R_{parallel}} = \frac{1}{R_1} + \frac{1}{R_2}\)</span></li>
<li>Repeat until the circuit is fully reduced</li>
</ol>
<p>This systematic approach works for any circuit that can be reduced using only series and parallel combinations.</p>
<h4 id="example-4-wheatstone-bridge-circuit">Example 4: Wheatstone Bridge Circuit</h4>
<p>A Wheatstone bridge circuit, which is a more complex configuration that includes a bridge resistor.</p>
<p><img alt="Wheatstone Bridge Circuit" src="../images/example_4_circuit.png"/></p>
<p>This graph shows a Wheatstone bridge circuit, a more complex configuration with a bridge resistor creating multiple paths between nodes. The algorithm handles this by performing a sequence of series and parallel reductions.</p>
<p>For bridge circuits, the equivalent resistance cannot be calculated using simple series-parallel reductions alone if we need the resistance between non-adjacent nodes. In such cases, we can use:</p>
<ol>
<li>Delta-Wye (Δ-Y) transformations</li>
<li>Nodal analysis using Kirchhoff's laws</li>
<li>Star-mesh transformations</li>
</ol>
<p>The graph theory approach elegantly handles these complex cases by representing the circuit topology and systematically applying reduction rules.</p>
<h2 id="analysis-and-efficiency">Analysis and Efficiency</h2>
<h3 id="algorithm-efficiency">Algorithm Efficiency</h3>
<p>The time complexity of the algorithm depends on the number of nodes and edges in the circuit graph:</p>
<ul>
<li>Identifying series nodes: O(n), where n is the number of nodes</li>
<li>Identifying parallel edges: O(e), where e is the number of edges</li>
<li>Each reduction step: O(1)</li>
<li>Overall algorithm: O(n² + e²) in the worst case, as each reduction removes at least one node or edge</li>
</ul>
<h3 id="limitations-and-potential-improvements">Limitations and Potential Improvements</h3>
<ol>
<li>
<p><strong>Complex Circuits</strong>: The current implementation may not handle all complex circuits, especially those requiring delta-wye transformations. Adding support for these transformations would make the algorithm more robust.</p>
</li>
<li>
<p><strong>Optimization</strong>: The algorithm could be optimized by prioritizing certain types of reductions or using more efficient data structures.</p>
</li>
<li>
<p><strong>Generalization</strong>: The approach could be extended to handle other circuit elements like capacitors and inductors, or to calculate other circuit properties like impedance in AC circuits.</p>
</li>
<li>
<p><strong>Parallelization</strong>: For very large circuits, parallel processing could be used to speed up the reduction process.</p>
</li>
</ol>
<h2 id="conclusion">Conclusion</h2>
<p>Graph theory provides a powerful and elegant approach to calculating equivalent resistance in electrical circuits. By representing circuits as graphs and applying systematic reduction rules, we can handle complex configurations that would be difficult to analyze using traditional methods.</p>
<p>The algorithm presented here demonstrates the effectiveness of this approach for a variety of circuit configurations, from simple series and parallel combinations to more complex mixed circuits. While there are limitations for extremely complex circuits, the graph-theoretic approach offers a solid foundation that can be extended with additional techniques like delta-wye transformations.</p>
<p>This application of graph theory to electrical circuit analysis highlights the interdisciplinary nature of the field and its practical relevance in engineering and physics. The systematic approach not only simplifies calculations but also provides deeper insights into the structure and behavior of electrical networks.</p>
</div>
</div><footer>
<div aria-label="Footer Navigation" class="rst-footer-buttons" role="navigation">
<a class="btn btn-neutral float-left" href="../../4%20Electromagnetism/Problem_1/" title="Simulating the Effects of the Lorentz Force"><span class="icon icon-circle-arrow-left"></span> Previous</a>
<a class="btn btn-neutral float-right" href="../../6%20Statistics/Problem_1/" title="Exploring the Central Limit Theorem through simulations">Next <span class="icon icon-circle-arrow-right"></span></a>
</div>
<hr/>
<div role="contentinfo">
<!-- Copyright etc -->
</div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
</div>
</div>
</section>
</div>
<div aria-label="Versions" class="rst-versions" role="note">
<span class="rst-current-version" data-toggle="rst-current-version">
<span><a href="../../4%20Electromagnetism/Problem_1/" style="color: #fcfcfc">« Previous</a></span>
<span><a href="../../6%20Statistics/Problem_1/" style="color: #fcfcfc">Next »</a></span>
</span>
</div>
<script src="../../../js/jquery-3.6.0.min.js"></script>
<script>var base_url = "../../..";</script>
<script src="../../../js/theme_extra.js"></script>
<script src="../../../js/theme.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<script src="../../../search/main.js"></script>
<script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>
</body>
</html>
